// Подключаем необходимые библиотеки и файл с определением исключений
#include <iostream>
#include "exception.cpp"

// Определяем шаблон класса Queue
template <class Item>
class Queue
{
    // Определяем структуру Element, которая будет хранить информацию об элементе очереди
    struct Element
    {
        Item inf; // Информационное поле
        Element *next; // Указатель на следующий элемент
        Element (Item x) : inf(x), next (0) {} // Конструктор для создания элемента
    };
    Element *head, *tail; // Указатели на голову и хвост очереди
public:
    // Конструктор класса
    Queue () : head(0), tail(0) {}
    
    // Метод проверки на пустоту очереди
    bool Empty()
    {
        return head == 0;
    }
    
    // Метод получения элемента из очереди
    Item Get()
    {
        if (Empty()){
            throw QueueException ("QueueException: get - queue empty"); // Если очередь пуста, выбрасываем исключение
        }
        else
        {
            Element *t = head; // Создаем временный указатель на голову очереди
            Item i = t->inf; // Получаем информационное поле элемента
            head = t->next; // Перемещаем голову на следующий элемент
            if (head == NULL)
            { 
                tail = NULL;
            }
            delete t; // Удаляем временный указатель
            return i; // Возвращаем информационное поле элемента
        }
    }

    // Метод добавления элемента в очередь
    void Put (Item data){
        Element *t = tail; // Создаем временный указатель на хвост очереди
        tail = new Element (data); // Создаем новый элемент и присваиваем его указателю на хвост
        if (!head)
        { 
            head = tail;
        }
        else
        {
            t->next = tail; // Связываем временный указатель на хвост с новым элементом
        }
    }

    // Метод удаления элементов с максимальным значением информационного поля
    void RemoveMax()
    {
        if (Empty()){
            throw QueueException ("QueueException: removeMax - queue empty"); // Если очередь пуста, выбрасываем исключение
        }
        else
        {
            Item max = head->inf; // Получаем максимальное значение информационного поля
            Element *current = head; // Создаем указатель на текущий элемент
            Element *previous = NULL; // Создаем указатель на предыдущий элемент
            while (current != NULL)
            {
                if (current->inf == max) // Если значение текущего элемента равно максимальному
                {
                    if (previous == NULL) // Если текущий элемент - голова очереди
                    {
                        head = current->next; // Перемещаем голову на следующий элемент
                    }
                    else
                    {
                        previous->next = current->next; // Связываем предыдущий элемент со следующим
                    }
                    Element *temp = current; // Создаем временный указатель на текущий элемент
                    current = current->next; // Перемещаем текущий указатель на следующий элемент
                    delete temp; // Удаляем временный указатель
                }
                else
                {
                    previous = current; // Сохраняем указатель на текущий элемент как предыдущий
                    current = current->next; // Перемещаем текущий указатель на следующий элемент
                }
            }
        }
    }

    // Метод вывода элементов очереди на экран
    void Print()
    {
        Element *current = head; // Создаем указатель на текущий элемент и присваиваем ему голову очереди
        while (current != NULL)
        {
            cout << current->inf << " "; // Выводим информационное поле текущего элемента на экран
            current = current->next; // Перемещаем указатель на следующий элемент
        }
        cout << endl; // Переводим курсор на новую строку
    }
};

// Главная функция программы
int main()
{
    Queue<int> q; // Создаем очередь
    q.Put(1); // Добавляем элементы
    q.Put(2);
    q.Put(3);
    q.Put(2);
    q.Put(4);
    q.Put(2);
    q.Put(5);

    q.RemoveMax(); // Удаляем элементы с максимальным значением информационного поля
    q.Print(); // Выводим элементы очереди на экран

    return 0; // Завершаем программу
}
